# RFC-0001: SPlayer 现代化提案

**状态**: 提案 (Proposed)  
**作者**: 开发团队  
**创建日期**: 2024-12-19  
**最后更新**: 2024-12-19

## 摘要

本文档提出对 SPlayer 媒体播放器项目进行全面现代化的技术提案。当前项目基于过时的技术栈（Visual Studio 2013、MFC、DirectShow），需要进行现代化改进以提升可维护性、安全性和用户体验。

## 1. 背景

### 1.1 当前状态

SPlayer 是一个基于 Media Player Classic 的 Windows 媒体播放器，具有以下特征：

- **编译环境**: Visual Studio 2013 (v120 toolset)
- **UI 框架**: Microsoft Foundation Classes (MFC)
- **媒体架构**: DirectShow
- **平台支持**: 仅 Win32 (32位)
- **字符编码**: Unicode/MultiByte 混合
- **C++ 标准**: 未明确指定，实际使用 C++98/03 特性

### 1.2 问题陈述

1. **技术债务**
   - Visual Studio 2013 已停止支持（2019年停止更新）
   - MFC 是 1990 年代的框架，UI 设计过时
   - DirectShow 已被 Microsoft 弃用
   - 第三方库版本过旧（如 OpenSSL 0.9.8x，存在安全风险）

2. **可维护性**
   - 代码混合使用 CString 和 std::wstring，类型转换频繁
   - 缺少现代 C++ 特性（智能指针、auto、范围 for 等）
   - 大量使用原始指针，内存管理复杂
   - 缺少单元测试和 CI/CD

3. **用户体验**
   - UI 设计过时，不支持现代扁平化设计
   - 高 DPI 支持不完善
   - 仅支持 32 位，无法充分利用现代硬件

4. **安全性**
   - 过时的第三方库存在已知安全漏洞
   - 缺少现代安全实践

## 2. 目标

### 2.1 主要目标

1. **可维护性提升**
   - 升级到现代编译环境（Visual Studio 2019/2022）
   - 引入现代 C++ 特性（C++11/14/17）
   - 统一代码风格和最佳实践
   - 建立 CI/CD 流程

2. **安全性增强**
   - 更新所有第三方库到最新安全版本
   - 修复已知安全漏洞
   - 采用现代安全实践

3. **用户体验改进**
   - 现代化 UI 设计
   - 完善高 DPI 支持
   - 支持 64 位平台

4. **架构优化**
   - 模块化设计
   - 分离关注点（MVC 模式）
   - 改进错误处理

### 2.2 非目标

- 不改变核心功能
- 不破坏向后兼容性（在可能的情况下）
- 不进行完全重写（除非必要）

## 3. 提案

### 3.1 阶段 1: 编译环境现代化 (P0)

**时间**: 1-2 周  
**优先级**: 最高

#### 3.1.1 升级 Visual Studio

- 从 Visual Studio 2013 (v120) 升级到 Visual Studio 2019 (v142) 或 2022 (v143)
- 更新所有 `.vcxproj` 文件中的 `PlatformToolset`
- 修复因工具集升级导致的编译错误

#### 3.1.2 添加 x64 支持

- 为所有项目添加 x64 平台配置
- 更新构建脚本支持 x64
- 测试 x64 构建

#### 3.1.3 更新 Windows SDK

- 从 Windows SDK 7.1 升级到 Windows SDK 10/11
- 更新 `WINVER` 和 `_WIN32_WINNT` 定义
- 修复因 SDK 升级导致的 API 变更

#### 3.1.4 更新第三方库

**关键库更新**:
- OpenSSL: 0.9.8x → 3.x
- Boost: 更新到最新版本
- 其他库: 检查并更新到安全版本

### 3.2 阶段 2: 代码现代化 (P1)

**时间**: 1-2 个月  
**优先级**: 高

#### 3.2.1 统一字符串类型

**问题**: 代码中混合使用 `CString` (MFC) 和 `std::wstring` (STL)

**方案**:
1. 新代码统一使用 `std::wstring`
2. 逐步将现有 `CString` 替换为 `std::wstring`
3. 使用 `std::wstring_view` 作为函数参数（C++17）

**迁移策略**:
- 创建适配层，逐步迁移
- 保持向后兼容，避免破坏性更改
- 充分测试每个模块

#### 3.2.2 引入智能指针

**问题**: 大量使用原始指针，内存管理复杂

**方案**:
- 使用 `std::unique_ptr` 替代单一所有权指针
- 使用 `std::shared_ptr` 替代共享所有权指针
- 使用 `std::weak_ptr` 打破循环引用

**示例**:
```cpp
// 旧代码
CGraphCore* m_pGraphCore;
delete m_pGraphCore;

// 新代码
std::unique_ptr<CGraphCore> m_pGraphCore;
// 自动管理内存
```

#### 3.2.3 现代 C++ 特性

引入以下 C++11/14/17 特性：

- `auto` 类型推导
- `nullptr` 替代 `NULL`
- `override` 和 `final` 关键字
- 范围 for 循环
- Lambda 表达式
- `std::optional` 错误处理
- `constexpr` 常量表达式
- `noexcept` 异常规范

#### 3.2.4 改进错误处理

**方案**:
- 使用 `std::optional` 表示可选值
- 使用异常处理替代错误码（在适当的地方）
- 创建统一的错误处理机制

### 3.3 阶段 3: UI 现代化 (P2)

**时间**: 3-6 个月  
**优先级**: 中

#### 3.3.1 UI 框架选择

**选项 A: MFC 改进** (保守)
- 使用现代控件库（BCGSoft, Codejock）
- 自定义绘制实现扁平化设计
- 添加高 DPI 支持

**优点**: 改动小，风险低  
**缺点**: 仍然受限于 MFC

**选项 B: Qt 迁移** (推荐)
- 迁移到 Qt 框架
- 使用 Qt Multimedia 替代 DirectShow
- 实现现代 Material Design 或 Fluent Design

**优点**: 
- 现代 UI 框架
- 跨平台支持
- 活跃的社区
- 内置媒体支持

**缺点**: 
- 工作量大
- 需要学习 Qt
- 可能丢失某些 DirectShow 特性

**选项 C: WinUI 3** (Windows 专用)
- 使用 WinUI 3 和 XAML
- 使用 Media Foundation 或 FFmpeg
- 实现 Fluent Design

**优点**: 
- 原生 Windows 现代 UI
- 性能好
- Microsoft 官方支持

**缺点**: 
- 仅 Windows 10/11
- 学习曲线陡峭
- 工作量大

#### 3.3.2 推荐方案

**推荐**: Qt 迁移

**理由**:
1. 跨平台支持，未来可扩展到 macOS/Linux
2. 现代 UI 框架，易于实现现代设计
3. Qt Multimedia 提供良好的媒体支持
4. 活跃的社区和丰富的文档
5. 商业许可友好（LGPL）

**迁移策略**:
1. 创建新的 Qt 项目结构
2. 逐步迁移 UI 组件
3. 使用 Qt Multimedia 替代 DirectShow
4. 保留 DirectShow 作为备选（如果需要）

### 3.4 阶段 4: 架构重构 (P3)

**时间**: 6-12 个月  
**优先级**: 低

#### 3.4.1 分离关注点

**当前问题**: 所有逻辑集中在 `CMainFrame`

**方案**: 采用 MVC 模式
- **Model**: 数据层（媒体信息、播放状态等）
- **View**: UI 层（窗口、控件等）
- **Controller**: 控制层（播放控制、事件处理等）

#### 3.4.2 模块化设计

- 将功能拆分为独立模块
- 使用插件架构
- 改进模块间通信

#### 3.4.3 媒体框架现代化

**选项**:
1. **FFmpeg**: 跨平台，功能强大，社区活跃
2. **Qt Multimedia**: 与 Qt UI 集成良好
3. **Media Foundation**: Windows 原生，性能好

**推荐**: FFmpeg（如果选择 Qt）或 Media Foundation（如果选择 WinUI）

## 4. 实施计划

### 4.1 时间表

| 阶段 | 时间 | 优先级 | 状态 |
|------|------|--------|------|
| 阶段 1: 编译环境现代化 | 1-2 周 | P0 | 待开始 |
| 阶段 2: 代码现代化 | 1-2 个月 | P1 | 待开始 |
| 阶段 3: UI 现代化 | 3-6 个月 | P2 | 待开始 |
| 阶段 4: 架构重构 | 6-12 个月 | P3 | 待开始 |

### 4.2 资源需求

- **开发人员**: 2-3 人
- **测试人员**: 1 人
- **UI/UX 设计师**: 1 人（UI 迁移时）

### 4.3 里程碑

1. **M1**: 编译环境升级完成，项目可在 VS2019/2022 编译
2. **M2**: 代码现代化完成，引入现代 C++ 特性
3. **M3**: UI 框架选择确定，开始迁移
4. **M4**: UI 现代化完成，新 UI 发布
5. **M5**: 架构重构完成，模块化设计实现

## 5. 风险评估

### 5.1 高风险

1. **UI 框架迁移**
   - **风险**: 工作量大，可能引入 bug
   - **缓解**: 分阶段进行，保留旧版本作为备份

2. **DirectShow 替换**
   - **风险**: 核心功能，影响大
   - **缓解**: 先在新功能中试用新框架，逐步迁移

3. **第三方库更新**
   - **风险**: 可能不兼容
   - **缓解**: 充分测试，保留旧版本作为回退

### 5.2 中风险

1. **编译环境升级**
   - **风险**: 可能遇到兼容性问题
   - **缓解**: 在独立分支进行，充分测试

2. **字符串类型统一**
   - **风险**: 工作量大，可能引入 bug
   - **缓解**: 逐步进行，充分测试

### 5.3 低风险

1. **现代 C++ 特性引入**
   - **风险**: 低
   - **缓解**: 可以逐步进行

## 6. 成功指标

### 6.1 编译指标

- ✅ 能在 Visual Studio 2019/2022 成功编译
- ✅ 支持 x64 平台
- ✅ 无编译警告
- ✅ CI/CD 构建通过

### 6.2 代码质量指标

- ✅ 代码覆盖率 > 70%
- ✅ 静态分析无严重问题
- ✅ 代码审查通过率 > 90%

### 6.3 性能指标

- ✅ 启动时间 < 2 秒
- ✅ 内存使用减少 20%
- ✅ 播放性能不下降

### 6.4 UI 指标

- ✅ 支持高 DPI
- ✅ 现代 UI 设计
- ✅ 用户满意度提升

## 7. 替代方案

### 7.1 方案 A: 渐进式现代化 (推荐)

**描述**: 分阶段逐步现代化，保持向后兼容

**优点**: 
- 风险可控
- 可以逐步验证
- 不影响现有功能

**缺点**: 
- 时间较长
- 可能遗留技术债务

### 7.2 方案 B: 完全重写

**描述**: 使用现代技术栈完全重写项目

**优点**: 
- 可以完全现代化
- 无历史包袱

**缺点**: 
- 工作量大
- 风险高
- 可能丢失功能

**建议**: 不推荐，除非有充足资源

## 8. 决策记录

### 8.1 已做决策

- ✅ 采用渐进式现代化方案
- ✅ 优先升级编译环境
- ✅ UI 框架选择 Qt（待确认）

### 8.2 待决策

- ⏳ UI 框架最终选择（Qt/WinUI3/MFC改进）
- ⏳ 媒体框架选择（FFmpeg/Qt Multimedia/Media Foundation）
- ⏳ 是否支持跨平台

## 9. 参考文献

- [编译与现代化分析.md](../../编译与现代化分析.md)
- [现代化实施计划.md](../../现代化实施计划.md)
- [Visual Studio 工具集版本](https://docs.microsoft.com/en-us/cpp/build/reference/toolset-version)
- [Qt 文档](https://doc.qt.io/)
- [FFmpeg 文档](https://ffmpeg.org/documentation.html)

## 10. 附录

### 10.1 术语表

- **MFC**: Microsoft Foundation Classes
- **DirectShow**: Microsoft 的媒体框架
- **Qt**: 跨平台 C++ 应用程序框架
- **WinUI 3**: Windows 现代 UI 框架
- **FFmpeg**: 跨平台多媒体框架

### 10.2 相关文档

- RFC-0002: UI 框架选择详细分析（待创建）
- RFC-0003: 媒体框架迁移方案（待创建）

---

**下一步行动**:
1. 评审本 RFC
2. 确定 UI 框架选择
3. 开始阶段 1 实施
